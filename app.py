from flask import Flask, jsonify
from flask_cors import CORS
import os
import sys
import joblib
import pandas as pd
sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))

from train_random_forest import train_model as train_rf_model  # H√†m train model RandomForest
from train_random_forest import train_model as train_rf_model
from train_xgboost import train_xgboost_model
    # H√†m train model XGBoost

app = Flask(__name__)
CORS(app)

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_PATH = os.path.join(BASE_DIR, "data", "data", "processed_sales.csv")
MODEL_RF_PATH = os.path.join(BASE_DIR, "models", "model_randomforest_sales.pkl")
MODEL_XGB_PATH = os.path.join(BASE_DIR, "models", "model_xgboost_sales.pkl")

def load_data():
    if not os.path.exists(DATA_PATH):
        raise FileNotFoundError(f"Kh√¥ng t√¨m th·∫•y file t·∫°i: {DATA_PATH}")
    return pd.read_csv(DATA_PATH)

def get_models(product_id):
    # N·∫øu ch∆∞a c√≥ model, train l·∫°i
    if not os.path.exists(MODEL_RF_PATH):
        train_rf_model(product_id)
    if not os.path.exists(MODEL_XGB_PATH):
        train_xgboost_model(product_id)
    # Lu√¥n t·∫£i model t·ª´ file
    model_rf = joblib.load(MODEL_RF_PATH)
    model_xgb = joblib.load(MODEL_XGB_PATH)
    return model_rf, model_xgb

@app.route('/train/<int:product_id>')
def train(product_id):
    try:
        train_rf_model(product_id)
        train_xgboost_model(product_id)
        return jsonify({"message": f"‚úî ƒê√£ train model RandomForest v√† XGBoost cho product_id={product_id}"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/predict/<int:product_id>')
def predict(product_id):
    try:
        model_rf, model_xgb = get_models(product_id)
        df = load_data()
        df_product = df[df['product_id'] == product_id]
        if df_product.empty:
            return jsonify({"error": f"Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho product_id={product_id}"}), 404

        # Chu·∫©n b·ªã d·ªØ li·ªáu nh√≥m theo th√°ng
        monthly_features = df_product.groupby(['year', 'month']).agg({
            'day': 'mean',
            'dayofweek': 'mean',
            'price': 'mean',
            'discount_price': 'mean',
            'stock': 'mean',
            'sold': 'mean',
            'category_code': 'first',
        }).reset_index()

        features = ['year', 'month', 'day', 'dayofweek', 'price', 'discount_price', 'stock', 'sold', 'category_code']

        # T·∫°o d·ªØ li·ªáu th√°ng ti·∫øp theo
        last_row = monthly_features.iloc[-1]
        year, month = int(last_row['year']), int(last_row['month'])

        if month == 12:
            next_year = year + 1
            next_month = 1
        else:
            next_year = year
            next_month = month + 1

        next_month_data = {
            'year': next_year,
            'month': next_month,
            'day': last_row['day'],
            'dayofweek': last_row['dayofweek'],
            'price': last_row['price'],
            'discount_price': last_row['discount_price'],
            'stock': last_row['stock'],
            'sold': last_row['sold'],
            'category_code': last_row['category_code'],
        }

        next_month_df = pd.DataFrame([next_month_data])
        X_next = next_month_df[features]

        y_pred_rf = model_rf.predict(X_next)[0]
        y_pred_xgb = model_xgb.predict(X_next)[0]
 # L·ªãch s·ª≠ b√°n h√†ng theo th√°ng
        history = df_product.groupby(['year', 'month']).agg({
            'sold': 'sum'
        }).reset_index().sort_values(['year', 'month'])

        return jsonify({
            "product_id": product_id,
            "next_month_prediction": {
                "year": next_year,
                "month": next_month,
                "predicted_quantity_sold_random_forest": float(round(y_pred_rf, 2)),
                "predicted_quantity_sold_xgboost": float(round(y_pred_xgb, 2)),
            },
            "history": history.to_dict(orient="records")  # üëà Th√™m d√≤ng n√†y
        })

    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True, port=5000)
